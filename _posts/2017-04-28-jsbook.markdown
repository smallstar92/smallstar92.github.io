---
layout:     post
title:      "《你不知道的javascript》上卷"
subtitle:   "作用域与闭包（一）——编译原理"
date:       2017-04-28 12:00:00
author:     "Small Star"
header-img: "img/js/post-js.jpg"
tags:
    - 你不知道的javascript
    - js

---

>在翻阅《你不知道的javascript》这一套书的中上卷目录之后，发现书中针对闭包、对象、原型、语法、异步、回调等等既基础又重要的
javascript知识有着针对性的阐述，于是决定对这套书的中上卷进行学习。上卷和中卷各讲述了两大部分知识，分别是：作用域与闭包、
this和对象原型、类型和语法、异步和性能。本文是对作用域与闭包的学习总结。

　　在第一部分中，尽管分为六章来进行叙述，但我认为主要分为三大块知识，分别是编译原理、作用域以及闭包机制，
依托于javascript引擎的编译原理规则，才能够形成作用域的理念，而依托于作用域的理念，才能够体现出闭包机制的作用。

　　对编译原理的掌握，需要了解的是：javascript编译的步骤，引擎、编译器、作用域三者之间的相互关系，以及查询机制。

　　1.javascript编译的步骤<br>
　　一般情况下，编程语言编译的步骤都是分词/词法分析、解析/语法分析、代码生成这样三步：

- 分词/词法分析：将字符串分解成代码块（也叫词法单元）就是分词，如果是在按照某种规则下进行的分词，就是词法分析；
- 解析/语法分析：将词法单元流转换成一个由元素逐级嵌套所组成的代表程序语法结构的树（抽象语法树，AST）。
javascript中的作用域基本上就是在这一阶段形成，也叫词法作用域。
- 代码生成：将AST转换成引擎可执行的代码的过程。

　　然而对于js引擎来说，编译过程要复杂一些：由于js引擎的大部分编译工作发生在代码执行前很短时间内（非常非常短），
因此在编译的时候，js引擎还需要做对代码的运行性能优化这一项工作（**此处是重点，因为性能优化是发生在这一个阶段，
所以在编写代码的时候，需要注意使代码不干预这一阶段的工作，在这一部分的后面章节中会有提到**）。

　　2.引擎、编译器、作用域三者之间的关系<br>
　　首先需要明确的一点是，编译器也是引擎的一部分，将其脱离出来单独作为主体，是为了更好的阐述这三方面的关系。
简单来说，由编译器通过分析词法来生成作用域中的变量、标识符等这样一些东西；而引擎在执行代码的过程中，
会在作用域中查找需要用到的标识符；作用域可以理解为代码执行及标识符储存的范围。<br>
　　简单以下声明为例来具体分析三者的作用：

	var a=2;

　　在对这个声明执行过程中，编译器会起到两个作用：
a.在作用域中查询a，如果a不存在则在作用域中声明a这个变量；
b.为引擎生成执行赋值这一动作的代码。<br>
　　而引擎也起到两个作用：
a.在作用域中查询a；
b.对a进行赋值。

　　3.查询机制
　　在上面一部分中，提到了查询，由此，需要了解引擎的查询机制。查询机制分为两种：LHS查询和RHS查询。
在书中对两种查询机制的原意进行了较为全面的阐述，总结下来，两种查询机制的关键点在：
- LHS查询：找到变量并为了给变量赋值，可理解为“赋值操作的目标是谁”；
- RHS查询：查找变量，确认有无变量，可理解为“谁是赋值操作的源头”；
<br>
<<<<<<< HEAD
　　同样，简单以以下一段代码为例，进行具体分析：
=======
　　同样，简单以以下一段代码为例，进行具体分析：<br>
>>>>>>> origin/master

	function foo(a) {
	console.log(a);
	}
	foo(2);

1.首先，引擎对foo这一标识符进行RHS查询，看是否存在，发现编译器已经声明的foo，代表一个函数；<br>
2.接着，引擎在执行函数阶段，对a执行了LHS查询，并将2这个值赋给它；<br>
3.接着，引擎对console进行了RHS查询，看是否存在，发现console及其子函数log()都是内置的方法；<br>
4.最后，引擎在log(a)中又看到了a，于是对a进行了一次RHS查询，发现a存在，并且在第二步的LHS查询中已经被赋值为2，于是将这个2传递进log(a)中的a。

　　两种查询都存在异常的情况，其异常也存在区别：
- 对RHS查询来说，如果在任何相关作用域（**此处需要了解作用域链的原理**）中都找不到变量，引擎就会抛出ReferenceError异常；
- 对LHS查询来说，如果找不到变量，会存在两种情况：非严格模式下，如果查不到变量，全局作用域会创建一个该变量，并返还引擎
（**此处需要注意，一般来说，js的作用域都是词法作用域，静态的，但在这种情况下，作用域却发生了改变，被语法进行了欺骗**）；
在严格模式下（ES5引进了严格模式），引擎同样会抛出ReferenceError异常，而作用域不会出现创建变量的动作。
此外，对查询结果的非法或不合理操作（**存在于LHS查询之后**），引擎会抛出TypeError异常。

　　以上，就是编译原理方面的知识。
